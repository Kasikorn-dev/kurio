import { and, eq } from "drizzle-orm"
import { z } from "zod"
import { generateGameContent } from "@/lib/ai/game-generator"
import { createTRPCRouter, protectedProcedure } from "@/server/api/trpc"
import {
	exercises,
	kurios,
	lessons,
	playerExercisePlays,
	playerLessonProgress,
	units,
} from "@/server/db/schemas"

export const gameRouter = createTRPCRouter({
	submitAnswer: protectedProcedure
		.input(
			z.object({
				exerciseId: z.string().uuid(),
				userAnswer: z.record(z.unknown()),
				isCorrect: z.boolean(),
				score: z.number().int(),
				timeSpent: z.number().int(),
			}),
		)
		.mutation(async ({ ctx, input }) => {
			// Get user profile ID
			const userProfile = await ctx.db.query.userProfiles.findFirst({
				where: (profiles, { eq }) => eq(profiles.userId, ctx.user.id),
			})

			if (!userProfile) {
				throw new Error("User profile not found")
			}

			// Record the play
			await ctx.db.insert(playerExercisePlays).values({
				playerId: userProfile.id,
				exerciseId: input.exerciseId,
				userAnswer: input.userAnswer,
				isCorrect: input.isCorrect,
				score: input.score,
				timeSpent: input.timeSpent,
			})

			// Update lesson progress
			const exercise = await ctx.db.query.exercises.findFirst({
				where: (exercises, { eq }) => eq(exercises.id, input.exerciseId),
				with: {
					lesson: {
						with: {
							exercises: true,
						},
					},
				},
			})

			if (exercise) {
				const totalExercises = exercise.lesson.exercises.length

				const existingProgress =
					await ctx.db.query.playerLessonProgress.findFirst({
						where: (progress, { eq, and }) =>
							and(
								eq(progress.playerId, userProfile.id),
								eq(progress.lessonId, exercise.lessonId),
							),
					})

				if (existingProgress) {
					await ctx.db
						.update(playerLessonProgress)
						.set({
							completedExercises: existingProgress.completedExercises + 1,
							isCompleted:
								existingProgress.completedExercises + 1 >=
								existingProgress.totalExercises,
							lastPlayedAt: new Date(),
							updatedAt: new Date(),
						})
						.where(
							and(
								eq(playerLessonProgress.playerId, userProfile.id),
								eq(playerLessonProgress.lessonId, exercise.lessonId),
							),
						)
				} else {
					// Create new progress record if it doesn't exist
					await ctx.db.insert(playerLessonProgress).values({
						playerId: userProfile.id,
						lessonId: exercise.lessonId,
						completedExercises: 1,
						totalExercises,
						isCompleted: 1 >= totalExercises,
						lastPlayedAt: new Date(),
					})
				}
			}

			return { success: true }
		}),

	getAllLessonProgress: protectedProcedure
		.input(z.object({ lessonIds: z.array(z.string().uuid()) }))
		.query(async ({ ctx, input }) => {
			const userProfile = await ctx.db.query.userProfiles.findFirst({
				where: (profiles, { eq }) => eq(profiles.userId, ctx.user.id),
			})

			if (!userProfile) {
				throw new Error("User profile not found")
			}

			if (input.lessonIds.length === 0) {
				return []
			}

			const progress = await ctx.db.query.playerLessonProgress.findMany({
				where: (progress, { eq, and, inArray }) =>
					and(
						eq(progress.playerId, userProfile.id),
						inArray(progress.lessonId, input.lessonIds),
					),
			})

			return progress
		}),

	generateGame: protectedProcedure
		.input(
			z.object({
				kurioId: z.string().uuid(),
			}),
		)
		.mutation(async ({ ctx, input }) => {
			// Get kurio with resources
			const kurio = await ctx.db.query.kurios.findFirst({
				where: (kurios, { eq }) => eq(kurios.id, input.kurioId),
				with: {
					resources: true,
				},
			})

			if (!kurio) {
				throw new Error("Kurio not found")
			}

			if (kurio.userId !== ctx.user.id) {
				throw new Error("Unauthorized")
			}

			// Generate game content using AI
			const gameContent = await generateGameContent({
				resources: kurio.resources.map((r) => ({
					resourceType: r.resourceType,
					resourceContent: r.resourceContent ?? undefined,
					resourceFileUrl: r.resourceFileUrl ?? undefined,
				})),
				difficultyLevel: kurio.difficultyLevel,
				aiModel: kurio.aiModel,
			})

			// Create units, lessons, and exercises
			let totalExercises = 0

			for (const unitData of gameContent.units) {
				const [unit] = await ctx.db
					.insert(units)
					.values({
						kurioId: kurio.id,
						title: unitData.title,
						orderIndex: gameContent.units.indexOf(unitData),
						isAutoGenerated: true,
					})
					.returning()

				if (!unit) {
					throw new Error("Failed to create unit")
				}

				for (const lessonData of unitData.lessons) {
					const [lesson] = await ctx.db
						.insert(lessons)
						.values({
							unitId: unit.id,
							title: lessonData.title,
							orderIndex: unitData.lessons.indexOf(lessonData),
							isAutoGenerated: true,
						})
						.returning()

					if (!lesson) {
						throw new Error("Failed to create lesson")
					}

					for (const exerciseData of lessonData.exercises) {
						await ctx.db.insert(exercises).values({
							lessonId: lesson.id,
							title: exerciseData.title,
							exerciseType: exerciseData.exerciseType,
							content: exerciseData.content,
							difficultyLevel: exerciseData.difficultyLevel,
							orderIndex: lessonData.exercises.indexOf(exerciseData),
							isAutoGenerated: true,
						})
						totalExercises++
					}
				}
			}

			// Update kurio status and total exercises
			await ctx.db
				.update(kurios)
				.set({
					status: "ready",
					totalExercises,
					updatedAt: new Date(),
				})
				.where(eq(kurios.id, kurio.id))

			return { success: true, totalExercises }
		}),
})
